=======
# Chara Language

Chara is a small toy language that compiles to native code using LLVM.  
It uses Flex for lexing, Bison for parsing, and the LLVM C API for code generation.

The current language is deliberately tiny, focused on experimenting with:

- A simple AST
- A function-based syntax
- String / number literals
- Function calls and variable assignments
- JIT-like codegen via LLVM (but producing native binaries)

---

## Language Overview

### Functions

A program is a list of function definitions.  
Each function has the form:

```chara
:name = do
  <statements...>
end <number>
```

`:name` — function name

`do ... end` — function body

Final `end <number>` — numeric return value of the function

#### Example (examples/main.chr):

```chara
:greet = do
  outs "Hello";
  out " world!";
end 0

:main = do
  greet;
  out (out "hi");
end 0
```

### Built-in functions
Codegen currently declares two built-in functions:

`outs(string)` — prints the string without a newline.

`out(string)` — prints the string with a newline

#### Example:

```chara
:main = do
  outs "Hello, ";
  out "Chara!";
end 0
```

### Statements
Inside a function body (do ... end), you can write:

- Function calls (optionally with arguments), ending with `;`:
  ```chara
  greet;
  out "Hello";
  out (out "nested");
  ```

- Variable assignments:
  ```chara
  x = 42;
  y = 10;
  ```

  Right now, expressions for assignments are limited to numbers and simple expressions that codegen supports.Statements are linked together via the AST and then lowered to LLVM IR.

- Expressions / Arguments

  Arguments to function calls can be:
    - String literals:
      ```chara
      out "Hello";
      ```

    - Number literals:
      ```chara
      myfunc 42;
      ```

    - Nested calls:
      ```chara
      out (out "hi");
      ```

    - Identifiers (parsed; codegen support for variable reads is partially implemented):
      ```chara
      x = 1;
      myfunc x;
      ```

## Project Layout
```
.
├── Makefile # Build rules
├── .clangd  # clangd configuration (include paths, defines)
├── src/
│   ├── main.c      # Entry point, drives parsing & compilation
│   ├── parser.y    # Bison grammar
│   ├── chara.l     # Flex lexer
│   ├── ast.h       # AST node definitions
│   ├── ast.c       # AST construction / printing
│   └── codegen.c   # LLVM IR generation and object file emission
├── gen/            # Generated by Bison/Flex (ignored by Git)
│   ├── parser.tab.c
│   ├── parser.tab.h
│   └── lex.yy.c
├── bin/            # Compiled objects & final compiler binary
└── examples/
    └── main.chr    # Example Chara program
```

## Prerequisites
- macOS
- Homebrew
- LLVM installed via Homebrew:
  ```bash
  $ brew install llvm lld
  ```
- Bison and Flex (if not already available):
  ```bash
  $ brew install bison flex
  ```
The Makefile uses `brew --prefix llvm` to locate LLVM and uses the LLVM-provided clang.

## Building
From the project root:
```bash
$ make
```
This will:

- Generate the parser and lexer into `gen`:
`gen/parser.tab.c`, `gen/parser.tab.h` (Bison)
`gen/lex.yy.c` (Flex)
- Compile all `.c` files into `bin/*.o`
- Link the final compiler executable: `bin/chara`

To clean generated files and build artifacts:
```bash
$ make clean
```

## Running Chara Programs
The `bin/chara` binary is the Chara compiler.

Basic usage:
```bash
$ ./bin/chara <file.chr>
```

### Example:

```bash
# Build the compiler
$ make

# Compile the example program
$ ./bin/chara examples/main.chr
```

This will:

- Parse `examples/main.chr` into an AST.
- Generate LLVM IR.
- Emit an object file next to the source: `examples/main.o`
- Link a native executable next to the source: `examples/main`
- Print:
  ```
  Successfully compiled: examples/main
  ```

Then you can run the generated binary:

```
./examples/main
```

Optionally, you can ask the compiler to dump the generated LLVM IR:

```bash
$ ./bin/chara ./examples/main.chr -llvm
```

## Development Notes

### Parser & Lexer
Grammar: `src/parser.y` (Bison)

Lexer: `src/chara.l` (Flex)

### The Makefile rules:

#### Bison

```Makefile
parser.tab.c parser.tab.c: parser.y
    bison -d -o gen/parser.tab.c src/parser.y
```

#### Flex

```Makefile
gen/lex.yy.c: src/chara.l gen/parser.tab.h
    flex -o gen/lex.yy.c src/chara.l
```

## AST
Defined in `src/ast.h`:

```c
typedef enum {
  NODE_PROG,
  NODE_FUNC,
  NODE_CALL,
  NODE_STR,
  NODE_NUM,
  NODE_IDENT,
  NODE_VAR,
} NodeType;
```

`create_node` and `print_ast` utilities are in `src/ast.c`.

## Code Generation
`src/codegen.c` uses the LLVM C API to:

- Declare helper functions (`outs` and `out`).
- Walk the AST and generate LLVM IR:
  - Function declarations and bodies
  - Calls
  - String and number constants
  - Basic variable storage/load (using alloca + store/load)

- `compile_to_object` uses LLVMTargetMachineEmitToFile to produce a .o file, then clang is used to link an executable.

## Editor / IntelliSense Setup
This project includes a .clangd file to help clangd find headers (including generated ones in `gen`):

```clangd
CompileFlags:
  Add: [
    "-Isrc",
    "-Igen",
    "-I/opt/homebrew/opt/llvm/include",
    "-D__STDC_CONSTANT_MACROS",
    "-D__STDC_FORMAT_MACROS",
    "-D__STDC_LIMIT_MACROS"
  ]
```

For best IDE support:

- Install the `clangd` VS Code extension.
- Ensure `bin` and `gen` exist (run `make` once).
- Reload the editor so `clangd` can index the project.

## Future Ideas
Some directions to extend Chara:

- Add more expression types (arithmetic, boolean, conditionals).
- Proper scoping and function parameters.
- Type checking.
- Better error reporting from the parser and compiler.
- REPL / JIT mode using LLVM’s MCJIT or ORC APIs.